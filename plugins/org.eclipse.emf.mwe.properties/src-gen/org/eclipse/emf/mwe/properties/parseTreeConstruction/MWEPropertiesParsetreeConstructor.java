/*
* generated by Xtext
*/
package org.eclipse.emf.mwe.properties.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.emf.mwe.properties.services.MWEPropertiesGrammarAccess;

import com.google.inject.Inject;

public class MWEPropertiesParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private MWEPropertiesGrammarAccess grammarAccess;
	
	@Override	
	public MWEPropertiesGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyFile_EntriesAssignment(this, this, 0, inst);
			case 1: return new NaturalLine_Alternatives(this, this, 1, inst);
			case 2: return new BlankLine_Group(this, this, 2, inst);
			case 3: return new PropertyComment_Group(this, this, 3, inst);
			case 4: return new PropertyEntry_Group(this, this, 4, inst);
			case 5: return new CompoundString_Alternatives(this, this, 5, inst);
			case 6: return new CompoundStringLeadingDelimiter_Alternatives(this, this, 6, inst);
			case 7: return new CompoundStringPartLeadingDelimiter_ValueAssignment(this, this, 7, inst);
			case 8: return new CompoundStringPart_ValueAssignment(this, this, 8, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule PropertyFile ****************
 *
 * PropertyFile:
 *   entries+=NaturalLine*;
 *
 **/

// entries+=NaturalLine*
protected class PropertyFile_EntriesAssignment extends AssignmentToken  {
	
	public PropertyFile_EntriesAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyFileAccess().getEntriesAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NaturalLine_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("entries",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("entries");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNaturalLineRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyFileAccess().getEntriesNaturalLineParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyFile_EntriesAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule PropertyFile ****************/


/************ begin Rule NaturalLine ****************
 *
 * NaturalLine:
 *   BlankLine|PropertyComment|PropertyEntry;
 *
 **/

// BlankLine|PropertyComment|PropertyEntry
protected class NaturalLine_Alternatives extends AlternativesToken {

	public NaturalLine_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNaturalLineAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NaturalLine_BlankLineParserRuleCall_0(parent, this, 0, inst);
			case 1: return new NaturalLine_PropertyCommentParserRuleCall_1(parent, this, 1, inst);
			case 2: return new NaturalLine_PropertyEntryParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNaturalLineRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BlankLine
protected class NaturalLine_BlankLineParserRuleCall_0 extends RuleCallToken {
	
	public NaturalLine_BlankLineParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNaturalLineAccess().getBlankLineParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlankLine_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BlankLine_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBlankLineRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PropertyComment
protected class NaturalLine_PropertyCommentParserRuleCall_1 extends RuleCallToken {
	
	public NaturalLine_PropertyCommentParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNaturalLineAccess().getPropertyCommentParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyComment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PropertyComment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPropertyCommentRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// PropertyEntry
protected class NaturalLine_PropertyEntryParserRuleCall_2 extends RuleCallToken {
	
	public NaturalLine_PropertyEntryParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNaturalLineAccess().getPropertyEntryParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PropertyEntry_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPropertyEntryRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NaturalLine ****************/


/************ begin Rule BlankLine ****************
 *
 * BlankLine:
 *   {BlankLine} WS? LINE_TERMINATOR;
 *
 **/

// {BlankLine} WS? LINE_TERMINATOR
protected class BlankLine_Group extends GroupToken {
	
	public BlankLine_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlankLineAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlankLine_LINE_TERMINATORTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBlankLineRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {BlankLine}
protected class BlankLine_BlankLineAction_0 extends ActionToken  {

	public BlankLine_BlankLineAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBlankLineAccess().getBlankLineAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBlankLineAccess().getBlankLineAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// WS?
protected class BlankLine_WSTerminalRuleCall_1 extends UnassignedTextToken {

	public BlankLine_WSTerminalRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBlankLineAccess().getWSTerminalRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlankLine_BlankLineAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// LINE_TERMINATOR
protected class BlankLine_LINE_TERMINATORTerminalRuleCall_2 extends UnassignedTextToken {

	public BlankLine_LINE_TERMINATORTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getBlankLineAccess().getLINE_TERMINATORTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlankLine_WSTerminalRuleCall_1(parent, this, 0, inst);
			case 1: return new BlankLine_BlankLineAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BlankLine ****************/


/************ begin Rule PropertyComment ****************
 *
 * PropertyComment:
 *   WS? value=SL_COMMENT LINE_TERMINATOR;
 *
 **/

// WS? value=SL_COMMENT LINE_TERMINATOR
protected class PropertyComment_Group extends GroupToken {
	
	public PropertyComment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyCommentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyComment_LINE_TERMINATORTerminalRuleCall_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyCommentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// WS?
protected class PropertyComment_WSTerminalRuleCall_0 extends UnassignedTextToken {

	public PropertyComment_WSTerminalRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPropertyCommentAccess().getWSTerminalRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// value=SL_COMMENT
protected class PropertyComment_ValueAssignment_1 extends AssignmentToken  {
	
	public PropertyComment_ValueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyCommentAccess().getValueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyComment_WSTerminalRuleCall_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getPropertyCommentAccess().getValueSL_COMMENTTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// LINE_TERMINATOR
protected class PropertyComment_LINE_TERMINATORTerminalRuleCall_2 extends UnassignedTextToken {

	public PropertyComment_LINE_TERMINATORTerminalRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPropertyCommentAccess().getLINE_TERMINATORTerminalRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyComment_ValueAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule PropertyComment ****************/


/************ begin Rule PropertyEntry ****************
 *
 * PropertyEntry:
 *   WS? name=Key (delimiter=Delimiter value=CompoundStringLeadingDelimiter|delimiter=
 *   SimpleDelimiter value=CompoundString);
 *
 **/

// WS? name=Key (delimiter=Delimiter value=CompoundStringLeadingDelimiter|delimiter=
// SimpleDelimiter value=CompoundString)
protected class PropertyEntry_Group extends GroupToken {
	
	public PropertyEntry_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_Alternatives_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPropertyEntryRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// WS?
protected class PropertyEntry_WSTerminalRuleCall_0 extends UnassignedTextToken {

	public PropertyEntry_WSTerminalRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getWSTerminalRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=Key
protected class PropertyEntry_NameAssignment_1 extends AssignmentToken  {
	
	public PropertyEntry_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_WSTerminalRuleCall_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getPropertyEntryAccess().getNameKeyParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// delimiter=Delimiter value=CompoundStringLeadingDelimiter|delimiter=
// SimpleDelimiter value=CompoundString
protected class PropertyEntry_Alternatives_2 extends AlternativesToken {

	public PropertyEntry_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_Group_2_0(parent, this, 0, inst);
			case 1: return new PropertyEntry_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// delimiter=Delimiter value=CompoundStringLeadingDelimiter
protected class PropertyEntry_Group_2_0 extends GroupToken {
	
	public PropertyEntry_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_ValueAssignment_2_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// delimiter=Delimiter
protected class PropertyEntry_DelimiterAssignment_2_0_0 extends AssignmentToken  {
	
	public PropertyEntry_DelimiterAssignment_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getDelimiterAssignment_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("delimiter",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("delimiter");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getPropertyEntryAccess().getDelimiterDelimiterParserRuleCall_2_0_0_0();
			return obj;
		}
		return null;
	}

}

// value=CompoundStringLeadingDelimiter
protected class PropertyEntry_ValueAssignment_2_0_1 extends AssignmentToken  {
	
	public PropertyEntry_ValueAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getValueAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundStringLeadingDelimiterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyEntryAccess().getValueCompoundStringLeadingDelimiterParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyEntry_DelimiterAssignment_2_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// delimiter=SimpleDelimiter value=CompoundString
protected class PropertyEntry_Group_2_1 extends GroupToken {
	
	public PropertyEntry_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_ValueAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// delimiter=SimpleDelimiter
protected class PropertyEntry_DelimiterAssignment_2_1_0 extends AssignmentToken  {
	
	public PropertyEntry_DelimiterAssignment_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getDelimiterAssignment_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PropertyEntry_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("delimiter",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("delimiter");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getPropertyEntryAccess().getDelimiterSimpleDelimiterParserRuleCall_2_1_0_0();
			return obj;
		}
		return null;
	}

}

// value=CompoundString
protected class PropertyEntry_ValueAssignment_2_1_1 extends AssignmentToken  {
	
	public PropertyEntry_ValueAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPropertyEntryAccess().getValueAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundStringRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPropertyEntryAccess().getValueCompoundStringParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new PropertyEntry_DelimiterAssignment_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule PropertyEntry ****************/




/************ begin Rule CompoundString ****************
 *
 * CompoundString:
 *   {CompoundString} LINE_TERMINATOR|parts+=CompoundStringPart ("\\" LINE_TERMINATOR WS?
 *   parts+=CompoundStringPartLeadingDelimiter)* LINE_TERMINATOR;
 *
 **/

// {CompoundString} LINE_TERMINATOR|parts+=CompoundStringPart ("\\" LINE_TERMINATOR WS?
// parts+=CompoundStringPartLeadingDelimiter)* LINE_TERMINATOR
protected class CompoundString_Alternatives extends AlternativesToken {

	public CompoundString_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_Group_0(parent, this, 0, inst);
			case 1: return new CompoundString_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundStringRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {CompoundString} LINE_TERMINATOR
protected class CompoundString_Group_0 extends GroupToken {
	
	public CompoundString_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_LINE_TERMINATORTerminalRuleCall_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {CompoundString}
protected class CompoundString_CompoundStringAction_0_0 extends ActionToken  {

	public CompoundString_CompoundStringAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getCompoundStringAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompoundStringAccess().getCompoundStringAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// LINE_TERMINATOR
protected class CompoundString_LINE_TERMINATORTerminalRuleCall_0_1 extends UnassignedTextToken {

	public CompoundString_LINE_TERMINATORTerminalRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getLINE_TERMINATORTerminalRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_CompoundStringAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// parts+=CompoundStringPart ("\\" LINE_TERMINATOR WS? parts+=
// CompoundStringPartLeadingDelimiter)* LINE_TERMINATOR
protected class CompoundString_Group_1 extends GroupToken {
	
	public CompoundString_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_LINE_TERMINATORTerminalRuleCall_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parts+=CompoundStringPart
protected class CompoundString_PartsAssignment_1_0 extends AssignmentToken  {
	
	public CompoundString_PartsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getPartsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringPart_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parts",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundStringPartRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundStringAccess().getPartsCompoundStringPartParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("\\" LINE_TERMINATOR WS? parts+=CompoundStringPartLeadingDelimiter)*
protected class CompoundString_Group_1_1 extends GroupToken {
	
	public CompoundString_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_PartsAssignment_1_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "\\"
protected class CompoundString_ReverseSolidusKeyword_1_1_0 extends KeywordToken  {
	
	public CompoundString_ReverseSolidusKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getReverseSolidusKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_Group_1_1(parent, this, 0, inst);
			case 1: return new CompoundString_PartsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// LINE_TERMINATOR
protected class CompoundString_LINE_TERMINATORTerminalRuleCall_1_1_1 extends UnassignedTextToken {

	public CompoundString_LINE_TERMINATORTerminalRuleCall_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getLINE_TERMINATORTerminalRuleCall_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_ReverseSolidusKeyword_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// WS?
protected class CompoundString_WSTerminalRuleCall_1_1_2 extends UnassignedTextToken {

	public CompoundString_WSTerminalRuleCall_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getWSTerminalRuleCall_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_LINE_TERMINATORTerminalRuleCall_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parts+=CompoundStringPartLeadingDelimiter
protected class CompoundString_PartsAssignment_1_1_3 extends AssignmentToken  {
	
	public CompoundString_PartsAssignment_1_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getPartsAssignment_1_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringPartLeadingDelimiter_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parts",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundStringPartLeadingDelimiterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundStringAccess().getPartsCompoundStringPartLeadingDelimiterParserRuleCall_1_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundString_WSTerminalRuleCall_1_1_2(parent, next, actIndex, consumed);
			case 1: return new CompoundString_LINE_TERMINATORTerminalRuleCall_1_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// LINE_TERMINATOR
protected class CompoundString_LINE_TERMINATORTerminalRuleCall_1_2 extends UnassignedTextToken {

	public CompoundString_LINE_TERMINATORTerminalRuleCall_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringAccess().getLINE_TERMINATORTerminalRuleCall_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundString_Group_1_1(parent, this, 0, inst);
			case 1: return new CompoundString_PartsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule CompoundString ****************/


/************ begin Rule CompoundStringLeadingDelimiter ****************
 *
 * CompoundStringLeadingDelimiter returns CompoundString:
 *   {EmptyPropertyValue} LINE_TERMINATOR|parts+=CompoundStringPartLeadingDelimiter (
 *   "\\" LINE_TERMINATOR WS? parts+=CompoundStringPartLeadingDelimiter)* LINE_TERMINATOR
 * ;
 *
 **/

// {EmptyPropertyValue} LINE_TERMINATOR|parts+=CompoundStringPartLeadingDelimiter (
// "\\" LINE_TERMINATOR WS? parts+=CompoundStringPartLeadingDelimiter)* LINE_TERMINATOR
protected class CompoundStringLeadingDelimiter_Alternatives extends AlternativesToken {

	public CompoundStringLeadingDelimiter_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_Group_0(parent, this, 0, inst);
			case 1: return new CompoundStringLeadingDelimiter_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundStringLeadingDelimiterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {EmptyPropertyValue} LINE_TERMINATOR
protected class CompoundStringLeadingDelimiter_Group_0 extends GroupToken {
	
	public CompoundStringLeadingDelimiter_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {EmptyPropertyValue}
protected class CompoundStringLeadingDelimiter_EmptyPropertyValueAction_0_0 extends ActionToken  {

	public CompoundStringLeadingDelimiter_EmptyPropertyValueAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getEmptyPropertyValueAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCompoundStringLeadingDelimiterAccess().getEmptyPropertyValueAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// LINE_TERMINATOR
protected class CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_0_1 extends UnassignedTextToken {

	public CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getLINE_TERMINATORTerminalRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_EmptyPropertyValueAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// parts+=CompoundStringPartLeadingDelimiter ("\\" LINE_TERMINATOR WS? parts+=
// CompoundStringPartLeadingDelimiter)* LINE_TERMINATOR
protected class CompoundStringLeadingDelimiter_Group_1 extends GroupToken {
	
	public CompoundStringLeadingDelimiter_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parts+=CompoundStringPartLeadingDelimiter
protected class CompoundStringLeadingDelimiter_PartsAssignment_1_0 extends AssignmentToken  {
	
	public CompoundStringLeadingDelimiter_PartsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getPartsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringPartLeadingDelimiter_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parts",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundStringPartLeadingDelimiterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundStringLeadingDelimiterAccess().getPartsCompoundStringPartLeadingDelimiterParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// ("\\" LINE_TERMINATOR WS? parts+=CompoundStringPartLeadingDelimiter)*
protected class CompoundStringLeadingDelimiter_Group_1_1 extends GroupToken {
	
	public CompoundStringLeadingDelimiter_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_PartsAssignment_1_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "\\"
protected class CompoundStringLeadingDelimiter_ReverseSolidusKeyword_1_1_0 extends KeywordToken  {
	
	public CompoundStringLeadingDelimiter_ReverseSolidusKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getReverseSolidusKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_Group_1_1(parent, this, 0, inst);
			case 1: return new CompoundStringLeadingDelimiter_PartsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// LINE_TERMINATOR
protected class CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_1_1 extends UnassignedTextToken {

	public CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getLINE_TERMINATORTerminalRuleCall_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_ReverseSolidusKeyword_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// WS?
protected class CompoundStringLeadingDelimiter_WSTerminalRuleCall_1_1_2 extends UnassignedTextToken {

	public CompoundStringLeadingDelimiter_WSTerminalRuleCall_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getWSTerminalRuleCall_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// parts+=CompoundStringPartLeadingDelimiter
protected class CompoundStringLeadingDelimiter_PartsAssignment_1_1_3 extends AssignmentToken  {
	
	public CompoundStringLeadingDelimiter_PartsAssignment_1_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getPartsAssignment_1_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringPartLeadingDelimiter_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("parts",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCompoundStringPartLeadingDelimiterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCompoundStringLeadingDelimiterAccess().getPartsCompoundStringPartLeadingDelimiterParserRuleCall_1_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_WSTerminalRuleCall_1_1_2(parent, next, actIndex, consumed);
			case 1: return new CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// LINE_TERMINATOR
protected class CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_2 extends UnassignedTextToken {

	public CompoundStringLeadingDelimiter_LINE_TERMINATORTerminalRuleCall_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCompoundStringLeadingDelimiterAccess().getLINE_TERMINATORTerminalRuleCall_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CompoundStringLeadingDelimiter_Group_1_1(parent, this, 0, inst);
			case 1: return new CompoundStringLeadingDelimiter_PartsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule CompoundStringLeadingDelimiter ****************/


/************ begin Rule CompoundStringPartLeadingDelimiter ****************
 *
 * CompoundStringPartLeadingDelimiter returns CompoundStringPart:
 *   value=CompoundStringPartLeadingDelimiterValue;
 *
 **/

// value=CompoundStringPartLeadingDelimiterValue
protected class CompoundStringPartLeadingDelimiter_ValueAssignment extends AssignmentToken  {
	
	public CompoundStringPartLeadingDelimiter_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundStringPartLeadingDelimiterAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundStringPartLeadingDelimiterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getCompoundStringPartLeadingDelimiterAccess().getValueCompoundStringPartLeadingDelimiterValueParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule CompoundStringPartLeadingDelimiter ****************/



/************ begin Rule CompoundStringPart ****************
 *
 * CompoundStringPart:
 *   value=CompoundStringPartValue;
 *
 **/

// value=CompoundStringPartValue
protected class CompoundStringPart_ValueAssignment extends AssignmentToken  {
	
	public CompoundStringPart_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCompoundStringPartAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCompoundStringPartRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getCompoundStringPartAccess().getValueCompoundStringPartValueParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule CompoundStringPart ****************/






}
