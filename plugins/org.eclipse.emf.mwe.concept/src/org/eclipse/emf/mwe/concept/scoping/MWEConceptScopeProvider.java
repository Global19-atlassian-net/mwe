/*
 * generated by Xtext
 */
package org.eclipse.emf.mwe.concept.scoping;

import java.util.List;
import java.util.Set;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.mwe.concept.mweConcept.Component;
import org.eclipse.emf.mwe.concept.mweConcept.FileRef;
import org.eclipse.emf.mwe.concept.mweConcept.MWEString;
import org.eclipse.emf.mwe.concept.mweConcept.PropertyFile;
import org.eclipse.emf.mwe.concept.mweConcept.ReplaceableString;
import org.eclipse.emf.mwe.concept.mweConcept.Setting;
import org.eclipse.emf.mwe.concept.mweConcept.util.MweConceptSwitch;
import org.eclipse.emf.mwe.properties.mweProperties.CompoundString;
import org.eclipse.emf.mwe.properties.mweProperties.CompoundStringPart;
import org.eclipse.emf.mwe.properties.mweProperties.PropertyEntry;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.FormalParameter;
import org.eclipse.xtext.common.types.Member;
import org.eclipse.xtext.common.types.Operation;
import org.eclipse.xtext.common.types.Type;
import org.eclipse.xtext.common.types.xtext.AbstractTypeScopeProvider;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.scoping.impl.AbstractScope;
import org.eclipse.xtext.util.Strings;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class MWEConceptScopeProvider extends AbstractDeclarativeScopeProvider {
	@Inject
	private AbstractTypeScopeProvider typeScopeProvider;
	
	public IScope scope_PropertyReference_property(EObject context, EReference reference) {
		IScope result = delegateGetScope(context, reference);
		return new FilteringScope(result, context);
	}
	
	public static class FilteringScope extends AbstractScope implements Predicate<IEObjectDescription> {

		private IScope outerScope;
		private IScope delegate;
		private EObject context;
		private Set<URI> resourceURIs;
		
		public FilteringScope(IScope filtered, EObject context) {
			this.delegate = filtered;
			this.context = context;
			if (filtered.getOuterScope() != filtered)
				this.outerScope = new FilteringScope(filtered.getOuterScope(), context);
			else
				this.outerScope = IScope.NULLSCOPE;
		}

		public Iterable<IEObjectDescription> internalGetContents() {
			return Iterables.filter(delegate.getContents(), this);
		}
		
		@Override
		public IEObjectDescription getContentByName(String name) {
			IEObjectDescription result = delegate.getContentByName(name);
			if (apply(result))
				return result;
			return null;
		}

		public IScope getOuterScope() {
			return outerScope;
		}
		
		private Set<URI> getFilterURIs() {
			if (resourceURIs == null) {
				resourceURIs = Sets.newHashSet();
				Resource eResource = context.eResource();
				List<PropertyFile> files = EcoreUtil2.getAllContentsOfType(eResource.getContents().get(0), PropertyFile.class);
				for(PropertyFile file: files) {
					FileRef fileRef = file.getFileRef();
					if (fileRef != null) {
						MWEString path = fileRef.getFilePath();
						if (path != null) {
							StringBuilder builder = new StringBuilder(64);
							new MWEStringBuilder(builder).doSwitch(path);
							if (builder.length() > 0) {
								String uri = builder.toString();
								if (EcoreUtil2.isValidUri(context, URI.createURI(uri))) {
									URI resolvedURI = getResolvedImportUri(context.eResource(), uri);
									resourceURIs.add(resolvedURI);
								}
							}
						}
					}
				}
			}
			return resourceURIs;
		}

		public boolean apply(IEObjectDescription input) {
			if (input == null)
				return true;
			EObject element = input.getEObjectOrProxy();
			if (element == null) {
				return true;
			}
			if (!element.eIsProxy())
				return true;
			
			InternalEObject internal = (InternalEObject) element;
			URI uri = internal.eProxyURI().trimFragment();
			return getFilterURIs().contains(uri);
		}
		
		private URI getResolvedImportUri(Resource context, String uri) {
			URI contextURI = context.getURI();
			URI newURI = URI.createURI(uri);
			if (contextURI.isHierarchical() && !contextURI.isRelative() && newURI.isRelative()) {
				newURI = newURI.resolve(contextURI);
			}
			return newURI;
		}
		
	}
	
	public static class MWEStringBuilder extends MweConceptSwitch<Boolean> {
		private final StringBuilder builder;

		public MWEStringBuilder(StringBuilder builder) {
			this.builder = builder;
		}
		
		@Override
		public Boolean caseCompoundStringPart(CompoundStringPart object) {
			builder.append(object.getValue());
			return true;
		}
		
		@Override
		public Boolean caseCompoundString(CompoundString object) {
			for(CompoundStringPart part: object.getParts())
				doSwitch(part);
			return true;
		}
		
		@Override
		public Boolean caseReplaceableString(ReplaceableString object) {
			if (object.getProperty() != null) {
				PropertyEntry property = object.getProperty().getProperty();
				if (property != null && !property.eIsProxy() && property.getValue() != null) {
					doSwitch(property.getValue());
				}
			}
			return true;
		}
	}
	
	public IScope scope_Setting_feature(Setting context, EReference reference) {
		if (context.eContainer() == null)
			throw new IllegalStateException("context.eContainer may not be null");
		if (!(context.eContainer() instanceof Component))
			throw new IllegalStateException("context.eContainer has to be instance of Component");
		Component container = (Component) context.eContainer();
		Type containerType = container.getType();
		if (containerType == null) {
			Setting setting = (Setting) container.eContainer();
			if (setting != null) {
				Operation containerFeature = setting.getFeature();
				if (containerFeature != null) {
					FormalParameter parameter = containerFeature.getParameters().get(0);
					containerType = parameter.getParameterType().getType();
				}
			}
		}
		return createOperationScope(containerType, IScope.NULLSCOPE);
	}
	
	public IScope createOperationScope(Type containerType, IScope outer) {
		return typeScopeProvider.createMemberScope(containerType, new Predicate<Member>() {
					public boolean apply(Member input) {
						if (input instanceof Operation) {
							Operation op = (Operation) input;
							String simpleName = op.getSimpleName();
							if (simpleName != null && simpleName.length() > 3 && 
								(simpleName.startsWith("add") || simpleName.startsWith("set"))) {
								return op.getParameters().size() == 1;
							}
						}
						return false;
					}
				}, new Function<Member, String>() {
				public String apply(Member from) {
					return Strings.toFirstLower(from.getSimpleName().substring(3));
				}}, outer);
	}

	public void setTypeScopeProvider(AbstractTypeScopeProvider typeScopeProvider) {
		this.typeScopeProvider = typeScopeProvider;
	}

	public AbstractTypeScopeProvider getTypeScopeProvider() {
		return typeScopeProvider;
	}
	
}
