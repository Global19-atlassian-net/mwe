/*
* generated by Xtext
*/
package org.eclipse.emf.mwe.di.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.emf.mwe.di.services.MWEGrammarAccess;

import com.google.inject.Inject;

public class MWEParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private MWEGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.prFile().getRule().getType().getType()) && (s = new File_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prImport().getRule().getType().getType()) && (s = new Import_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prJavaImport().getRule().getType().getType()) && (s = new JavaImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prGenericImport().getRule().getType().getType()) && (s = new GenericImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prProperty().getRule().getType().getType()) && (s = new Property_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prLocalVariable().getRule().getType().getType()) && (s = new LocalVariable_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prPropertiesFileImport().getRule().getType().getType()) && (s = new PropertiesFileImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prValue().getRule().getType().getType()) && (s = new Value_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prSimpleValue().getRule().getType().getType()) && (s = new SimpleValue_Assignment_value(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAssignable().getRule().getType().getType()) && (s = new Assignable_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prComplexValue().getRule().getType().getType()) && (s = new ComplexValue_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prWorkflowRef().getRule().getType().getType()) && (s = new WorkflowRef_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prIdRef().getRule().getType().getType()) && (s = new IdRef_Assignment_id(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAssignment().getRule().getType().getType()) && (s = new Assignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prQualifiedName().getRule().getType().getType()) && (s = new QualifiedName_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule File ****************
 *
 * not supported
 *
 **/


// not supported
protected class File_Group extends GroupToken {
	
	public File_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFile().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new File_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new File_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class File_0_Group extends GroupToken {
	
	public File_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFile().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new File_0_1_Assignment_properties(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new File_0_0_Assignment_imports(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class File_0_0_Assignment_imports extends AssignmentToken  {
	
	public File_0_0_Assignment_imports(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFile().ele00AssignmentImports();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("imports",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prImport().getRule().getType().getType())) {
				Solution s = new Import_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class File_0_1_Assignment_properties extends AssignmentToken  {
	
	public File_0_1_Assignment_properties(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFile().ele01AssignmentProperties();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("properties",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("properties");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prProperty().getRule().getType().getType())) {
				Solution s = new Property_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class File_1_Assignment_value extends AssignmentToken  {
	
	public File_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFile().ele1AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prComplexValue().getRule().getType().getType())) {
				Solution s = new ComplexValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule File ****************/


/************ begin Rule Import ****************
 *
 * not supported
 *
 **/


// not supported
protected class Import_Alternatives extends AlternativesToken {

	public Import_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prImport().eleAlternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Import_1_RuleCall_GenericImport(current, this) : new Import_0_RuleCall_JavaImport(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Import_0_RuleCall_JavaImport extends RuleCallToken {
	
	public Import_0_RuleCall_JavaImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prImport().ele0ParserRuleCallJavaImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(JavaImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prJavaImport().getRule().getType().getType())) return null;
		return new JavaImport_Group(current, this).firstSolution();
	}
}

// not supported
protected class Import_1_RuleCall_GenericImport extends RuleCallToken {
	
	public Import_1_RuleCall_GenericImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prImport().ele1ParserRuleCallGenericImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(GenericImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prGenericImport().getRule().getType().getType())) return null;
		return new GenericImport_Group(current, this).firstSolution();
	}
}


/************ end Rule Import ****************/


/************ begin Rule JavaImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class JavaImport_Group extends GroupToken {
	
	public JavaImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaImport().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class JavaImport_0_Group extends GroupToken {
	
	public JavaImport_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaImport().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_0_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class JavaImport_0_0_Group extends GroupToken {
	
	public JavaImport_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaImport().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_0_0_1_Assignment_javaImport(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_0_0_0_Keyword_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class JavaImport_0_0_0_Keyword_import extends KeywordToken  {
	
	public JavaImport_0_0_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaImport().ele000KeywordImport();
	}	
}

// not supported
protected class JavaImport_0_0_1_Assignment_javaImport extends AssignmentToken  {
	
	public JavaImport_0_0_1_Assignment_javaImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prJavaImport().ele001AssignmentJavaImport();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("javaImport",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("javaImport");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prQualifiedName().getRule().getType().getType())) {
				Solution s = new QualifiedName_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class JavaImport_0_1_Group extends GroupToken {
	
	public JavaImport_0_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaImport().ele01Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_0_1_1_Assignment_wildcard(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_0_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class JavaImport_0_1_0_Keyword extends KeywordToken  {
	
	public JavaImport_0_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaImport().ele010KeywordFullStop();
	}	
}

// not supported
protected class JavaImport_0_1_1_Assignment_wildcard extends AssignmentToken  {
	
	public JavaImport_0_1_1_Assignment_wildcard(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prJavaImport().ele011AssignmentWildcard();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("wildcard",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("wildcard");

		if(Boolean.TRUE.equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prJavaImport().ele0110KeywordAsterisk();
			return new Solution(obj);
		}

		return null;
	}
}



// not supported
protected class JavaImport_1_Keyword extends KeywordToken  {
	
	public JavaImport_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaImport().ele1KeywordSemicolon();
	}	
}


/************ end Rule JavaImport ****************/


/************ begin Rule GenericImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class GenericImport_Group extends GroupToken {
	
	public GenericImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGenericImport().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new GenericImport_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new GenericImport_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class GenericImport_0_Group extends GroupToken {
	
	public GenericImport_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGenericImport().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new GenericImport_0_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new GenericImport_0_0_Keyword_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class GenericImport_0_0_Keyword_import extends KeywordToken  {
	
	public GenericImport_0_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGenericImport().ele00KeywordImport();
	}	
}

// not supported
protected class GenericImport_0_1_Assignment_value extends AssignmentToken  {
	
	public GenericImport_0_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGenericImport().ele01AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prGenericImport().ele010LexerRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class GenericImport_1_Keyword extends KeywordToken  {
	
	public GenericImport_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGenericImport().ele1KeywordSemicolon();
	}	
}


/************ end Rule GenericImport ****************/


/************ begin Rule Property ****************
 *
 * not supported
 *
 **/


// not supported
protected class Property_Alternatives extends AlternativesToken {

	public Property_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prProperty().eleAlternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Property_1_RuleCall_PropertiesFileImport(current, this) : new Property_0_RuleCall_LocalVariable(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Property_0_RuleCall_LocalVariable extends RuleCallToken {
	
	public Property_0_RuleCall_LocalVariable(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prProperty().ele0ParserRuleCallLocalVariable();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(LocalVariable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prLocalVariable().getRule().getType().getType())) return null;
		return new LocalVariable_Group(current, this).firstSolution();
	}
}

// not supported
protected class Property_1_RuleCall_PropertiesFileImport extends RuleCallToken {
	
	public Property_1_RuleCall_PropertiesFileImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prProperty().ele1ParserRuleCallPropertiesFileImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(PropertiesFileImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prPropertiesFileImport().getRule().getType().getType())) return null;
		return new PropertiesFileImport_Group(current, this).firstSolution();
	}
}


/************ end Rule Property ****************/


/************ begin Rule LocalVariable ****************
 *
 * not supported
 *
 **/


// not supported
protected class LocalVariable_Group extends GroupToken {
	
	public LocalVariable_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prLocalVariable().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new LocalVariable_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new LocalVariable_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class LocalVariable_0_Group extends GroupToken {
	
	public LocalVariable_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prLocalVariable().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new LocalVariable_0_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new LocalVariable_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class LocalVariable_0_0_Group extends GroupToken {
	
	public LocalVariable_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prLocalVariable().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new LocalVariable_0_0_1_Assignment_name(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new LocalVariable_0_0_0_Keyword_var(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class LocalVariable_0_0_0_Keyword_var extends KeywordToken  {
	
	public LocalVariable_0_0_0_Keyword_var(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prLocalVariable().ele000KeywordVar();
	}	
}

// not supported
protected class LocalVariable_0_0_1_Assignment_name extends AssignmentToken  {
	
	public LocalVariable_0_0_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prLocalVariable().ele001AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prLocalVariable().ele0010LexerRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class LocalVariable_0_1_Group extends GroupToken {
	
	public LocalVariable_0_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prLocalVariable().ele01Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new LocalVariable_0_1_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new LocalVariable_0_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class LocalVariable_0_1_0_Keyword extends KeywordToken  {
	
	public LocalVariable_0_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prLocalVariable().ele010KeywordEqualsSign();
	}	
}

// not supported
protected class LocalVariable_0_1_1_Assignment_value extends AssignmentToken  {
	
	public LocalVariable_0_1_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prLocalVariable().ele011AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prValue().getRule().getType().getType())) {
				Solution s = new Value_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class LocalVariable_1_Keyword extends KeywordToken  {
	
	public LocalVariable_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prLocalVariable().ele1KeywordSemicolon();
	}	
}


/************ end Rule LocalVariable ****************/


/************ begin Rule PropertiesFileImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class PropertiesFileImport_Group extends GroupToken {
	
	public PropertiesFileImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new PropertiesFileImport_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new PropertiesFileImport_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class PropertiesFileImport_0_Group extends GroupToken {
	
	public PropertiesFileImport_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new PropertiesFileImport_0_1_Assignment_file(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new PropertiesFileImport_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class PropertiesFileImport_0_0_Group extends GroupToken {
	
	public PropertiesFileImport_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new PropertiesFileImport_0_0_1_Keyword_file(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new PropertiesFileImport_0_0_0_Keyword_var(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class PropertiesFileImport_0_0_0_Keyword_var extends KeywordToken  {
	
	public PropertiesFileImport_0_0_0_Keyword_var(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().ele000KeywordVar();
	}	
}

// not supported
protected class PropertiesFileImport_0_0_1_Keyword_file extends KeywordToken  {
	
	public PropertiesFileImport_0_0_1_Keyword_file(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().ele001KeywordFile();
	}	
}


// not supported
protected class PropertiesFileImport_0_1_Assignment_file extends AssignmentToken  {
	
	public PropertiesFileImport_0_1_Assignment_file(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().ele01AssignmentFile();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("file",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("file");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prPropertiesFileImport().ele010LexerRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class PropertiesFileImport_1_Keyword extends KeywordToken  {
	
	public PropertiesFileImport_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prPropertiesFileImport().ele1KeywordSemicolon();
	}	
}


/************ end Rule PropertiesFileImport ****************/


/************ begin Rule Value ****************
 *
 * not supported
 *
 **/


// not supported
protected class Value_Alternatives extends AlternativesToken {

	public Value_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prValue().eleAlternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Value_1_RuleCall_WorkflowRef(current, this) : new Value_0_Alternatives(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Value_0_Alternatives extends AlternativesToken {

	public Value_0_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prValue().ele0Alternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Value_0_1_RuleCall_IdRef(current, this) : new Value_0_0_Alternatives(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Value_0_0_Alternatives extends AlternativesToken {

	public Value_0_0_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prValue().ele00Alternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Value_0_0_1_RuleCall_ComplexValue(current, this) : new Value_0_0_0_RuleCall_SimpleValue(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Value_0_0_0_RuleCall_SimpleValue extends RuleCallToken {
	
	public Value_0_0_0_RuleCall_SimpleValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prValue().ele000ParserRuleCallSimpleValue();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(SimpleValue_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prSimpleValue().getRule().getType().getType())) return null;
		return new SimpleValue_Assignment_value(current, this).firstSolution();
	}
}

// not supported
protected class Value_0_0_1_RuleCall_ComplexValue extends RuleCallToken {
	
	public Value_0_0_1_RuleCall_ComplexValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prValue().ele001ParserRuleCallComplexValue();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ComplexValue_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prComplexValue().getRule().getType().getType())) return null;
		return new ComplexValue_Group(current, this).firstSolution();
	}
}


// not supported
protected class Value_0_1_RuleCall_IdRef extends RuleCallToken {
	
	public Value_0_1_RuleCall_IdRef(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prValue().ele01ParserRuleCallIdRef();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(IdRef_Assignment_id.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prIdRef().getRule().getType().getType())) return null;
		return new IdRef_Assignment_id(current, this).firstSolution();
	}
}


// not supported
protected class Value_1_RuleCall_WorkflowRef extends RuleCallToken {
	
	public Value_1_RuleCall_WorkflowRef(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prValue().ele1ParserRuleCallWorkflowRef();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(WorkflowRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prWorkflowRef().getRule().getType().getType())) return null;
		return new WorkflowRef_Group(current, this).firstSolution();
	}
}


/************ end Rule Value ****************/


/************ begin Rule SimpleValue ****************
 *
 * not supported
 *
 **/


// not supported
protected class SimpleValue_Assignment_value extends AssignmentToken  {
	
	public SimpleValue_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSimpleValue().eleAssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSimpleValue().ele0LexerRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule SimpleValue ****************/


/************ begin Rule Assignable ****************
 *
 * not supported
 *
 **/


// not supported
protected class Assignable_Alternatives extends AlternativesToken {

	public Assignable_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAssignable().eleAlternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Assignable_1_RuleCall_WorkflowRef(current, this) : new Assignable_0_RuleCall_ComplexValue(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Assignable_0_RuleCall_ComplexValue extends RuleCallToken {
	
	public Assignable_0_RuleCall_ComplexValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAssignable().ele0ParserRuleCallComplexValue();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ComplexValue_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prComplexValue().getRule().getType().getType())) return null;
		return new ComplexValue_Group(current, this).firstSolution();
	}
}

// not supported
protected class Assignable_1_RuleCall_WorkflowRef extends RuleCallToken {
	
	public Assignable_1_RuleCall_WorkflowRef(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAssignable().ele1ParserRuleCallWorkflowRef();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(WorkflowRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prWorkflowRef().getRule().getType().getType())) return null;
		return new WorkflowRef_Group(current, this).firstSolution();
	}
}


/************ end Rule Assignable ****************/


/************ begin Rule ComplexValue ****************
 *
 * not supported
 *
 **/


// not supported
protected class ComplexValue_Group extends GroupToken {
	
	public ComplexValue_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prComplexValue().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new ComplexValue_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ComplexValue_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class ComplexValue_0_Group extends GroupToken {
	
	public ComplexValue_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prComplexValue().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new ComplexValue_0_1_Assignment_assignments(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ComplexValue_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class ComplexValue_0_0_Group extends GroupToken {
	
	public ComplexValue_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prComplexValue().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new ComplexValue_0_0_1_Assignment_fooBar(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ComplexValue_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class ComplexValue_0_0_0_Group extends GroupToken {
	
	public ComplexValue_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prComplexValue().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new ComplexValue_0_0_0_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ComplexValue_0_0_0_0_Assignment_className(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class ComplexValue_0_0_0_0_Assignment_className extends AssignmentToken  {
	
	public ComplexValue_0_0_0_0_Assignment_className(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prComplexValue().ele0000AssignmentClassName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("className",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("className");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prQualifiedName().getRule().getType().getType())) {
				Solution s = new QualifiedName_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class ComplexValue_0_0_0_1_Group extends GroupToken {
	
	public ComplexValue_0_0_0_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prComplexValue().ele0001Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new ComplexValue_0_0_0_1_1_Assignment_id(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ComplexValue_0_0_0_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class ComplexValue_0_0_0_1_0_Keyword extends KeywordToken  {
	
	public ComplexValue_0_0_0_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prComplexValue().ele00010KeywordColon();
	}	
}

// not supported
protected class ComplexValue_0_0_0_1_1_Assignment_id extends AssignmentToken  {
	
	public ComplexValue_0_0_0_1_1_Assignment_id(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prComplexValue().ele00011AssignmentId();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("id",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prComplexValue().ele000110LexerRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



// not supported
protected class ComplexValue_0_0_1_Assignment_fooBar extends AssignmentToken  {
	
	public ComplexValue_0_0_1_Assignment_fooBar(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prComplexValue().ele001AssignmentFooBar();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("fooBar",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fooBar");

		if(Boolean.TRUE.equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prComplexValue().ele0010KeywordLeftCurlyBracket();
			return new Solution(obj);
		}

		return null;
	}
}


// not supported
protected class ComplexValue_0_1_Assignment_assignments extends AssignmentToken  {
	
	public ComplexValue_0_1_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prComplexValue().ele01AssignmentAssignments();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAssignment().getRule().getType().getType())) {
				Solution s = new Assignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class ComplexValue_1_Keyword extends KeywordToken  {
	
	public ComplexValue_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prComplexValue().ele1KeywordRightCurlyBracket();
	}	
}


/************ end Rule ComplexValue ****************/


/************ begin Rule WorkflowRef ****************
 *
 * not supported
 *
 **/


// not supported
protected class WorkflowRef_Group extends GroupToken {
	
	public WorkflowRef_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prWorkflowRef().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new WorkflowRef_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new WorkflowRef_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class WorkflowRef_0_Group extends GroupToken {
	
	public WorkflowRef_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new WorkflowRef_0_1_Assignment_assignments(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new WorkflowRef_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class WorkflowRef_0_0_Group extends GroupToken {
	
	public WorkflowRef_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new WorkflowRef_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new WorkflowRef_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class WorkflowRef_0_0_0_Group extends GroupToken {
	
	public WorkflowRef_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new WorkflowRef_0_0_0_1_Assignment_uri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new WorkflowRef_0_0_0_0_Keyword_file(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class WorkflowRef_0_0_0_0_Keyword_file extends KeywordToken  {
	
	public WorkflowRef_0_0_0_0_Keyword_file(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele0000KeywordFile();
	}	
}

// not supported
protected class WorkflowRef_0_0_0_1_Assignment_uri extends AssignmentToken  {
	
	public WorkflowRef_0_0_0_1_Assignment_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele0001AssignmentUri();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("uri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("uri");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prWorkflowRef().ele00010LexerRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class WorkflowRef_0_0_1_Keyword extends KeywordToken  {
	
	public WorkflowRef_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele001KeywordLeftCurlyBracket();
	}	
}


// not supported
protected class WorkflowRef_0_1_Assignment_assignments extends AssignmentToken  {
	
	public WorkflowRef_0_1_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele01AssignmentAssignments();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAssignment().getRule().getType().getType())) {
				Solution s = new Assignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class WorkflowRef_1_Keyword extends KeywordToken  {
	
	public WorkflowRef_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prWorkflowRef().ele1KeywordRightCurlyBracket();
	}	
}


/************ end Rule WorkflowRef ****************/


/************ begin Rule IdRef ****************
 *
 * not supported
 *
 **/


// not supported
protected class IdRef_Assignment_id extends AssignmentToken  {
	
	public IdRef_Assignment_id(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prIdRef().eleAssignmentId();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("id",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prIdRef().ele0LexerRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule IdRef ****************/


/************ begin Rule Assignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignment().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Assignment_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Assignment_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Assignment_0_Group extends GroupToken {
	
	public Assignment_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignment().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Assignment_0_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Assignment_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Assignment_0_0_Group extends GroupToken {
	
	public Assignment_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignment().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Assignment_0_0_1_Assignment_operator(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Assignment_0_0_0_Assignment_feature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Assignment_0_0_0_Assignment_feature extends AssignmentToken  {
	
	public Assignment_0_0_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignment().ele000AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAssignment().ele0000LexerRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class Assignment_0_0_1_Assignment_operator extends AssignmentToken  {
	
	public Assignment_0_0_1_Assignment_operator(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignment().ele001AssignmentOperator();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("operator",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");

		if("=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAssignment().ele00100KeywordEqualsSign();
			return new Solution(obj);
		}


		if("+=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAssignment().ele00101KeywordPlusSignEqualsSign();
			return new Solution(obj);
		}

		return null;
	}
}


// not supported
protected class Assignment_0_1_Assignment_value extends AssignmentToken  {
	
	public Assignment_0_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignment().ele01AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prValue().getRule().getType().getType())) {
				Solution s = new Value_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class Assignment_1_Keyword extends KeywordToken  {
	
	public Assignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAssignment().ele1KeywordSemicolon();
	}	
}


/************ end Rule Assignment ****************/


/************ begin Rule QualifiedName ****************
 *
 * not supported
 *
 **/


// not supported
protected class QualifiedName_Group extends GroupToken {
	
	public QualifiedName_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prQualifiedName().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new QualifiedName_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new QualifiedName_0_Assignment_parts(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class QualifiedName_0_Assignment_parts extends AssignmentToken  {
	
	public QualifiedName_0_Assignment_parts(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prQualifiedName().ele0AssignmentParts();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("parts",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prQualifiedName().ele00LexerRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class QualifiedName_1_Group extends GroupToken {
	
	public QualifiedName_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prQualifiedName().ele1Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new QualifiedName_1_1_Assignment_parts(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new QualifiedName_1_0_Assignment_parts(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class QualifiedName_1_0_Assignment_parts extends AssignmentToken  {
	
	public QualifiedName_1_0_Assignment_parts(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prQualifiedName().ele10AssignmentParts();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("parts",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");

		if(".".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prQualifiedName().ele100KeywordFullStop();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class QualifiedName_1_1_Assignment_parts extends AssignmentToken  {
	
	public QualifiedName_1_1_Assignment_parts(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prQualifiedName().ele11AssignmentParts();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("parts",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("parts");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prQualifiedName().ele110LexerRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule QualifiedName ****************/

}
